%scala
import java.util.Properties
val connectionProperties = new Properties()
var jdbcPassword = dbutils.secrets.get(scope = "OI_Secrets", key = "oifrontdbo")
connectionProperties.put("user", s"oifrontdbowner")
connectionProperties.put("password", s"${jdbcPassword}")


%scala
import java.sql.DriverManager

val connection = DriverManager.getConnection(jdbcHostname+":1433;"+"database="+jdbcDatabase+";"+"user= oifrontdbowner;"+"password="+s"${jdbcPassword}"+";encrypt=true;"+"trustServerCertificate=false;"+"hostNameInCertificate=*.database.windows.net;"+"loginTimeout=30")

//connection.isClosed()
connection.isValid(30)


%scala
val driverClass = "com.microsoft.sqlserver.jdbc.SQLServerDriver"
connectionProperties.setProperty("Driver", driverClass)



%scala
import java.sql.Statement
val dropstmt: Statement = connection.createStatement()
dropstmt.executeUpdate("DROP table IF EXISTS idn_product_offers_quarterly_bkp")
dropstmt.close()



%scala
import java.sql.Statement
val execstmt: Statement = connection.createStatement()
execstmt.executeUpdate("exec sp_rename 'idn_product_offers_quarterly_dummy','idn_product_offers_quarterly'")
execstmt.close()



%scala
connection.close()

















// Cell 1: Set up connection properties
%scala
import java.util.Properties
val connectionProperties = new Properties()
var jdbcPassword = dbutils.secrets.get(scope = "OI_Secrets", key = "oifrontdbo")
connectionProperties.put("user", s"oifrontdbowner")
connectionProperties.put("password", s"${jdbcPassword}")

// Cell 2: Set up JDBC connection string (make sure jdbcHostname and jdbcDatabase are defined)
%scala
// If not already defined, set these variables:
// val jdbcHostname = "your-server-name.database.windows.net"
// val jdbcDatabase = "your-database-name"

val jdbcUrl = s"jdbc:sqlserver://${jdbcHostname}:1433;database=${jdbcDatabase};encrypt=true;trustServerCertificate=false;hostNameInCertificate=*.database.windows.net;loginTimeout=30"

// Cell 3: Set driver class
%scala
val driverClass = "com.microsoft.sqlserver.jdbc.SQLServerDriver"
connectionProperties.setProperty("Driver", driverClass)

// Cell 4: Read the Databricks table
%scala
val orderHeaderDF = spark.table("order_header")

// Cell 5: Write data to SQL Server
%scala
orderHeaderDF.write
  .mode("overwrite")  // Change to "append" if you want to add data instead of replacing
  .jdbc(jdbcUrl, "order_header_sql_server", connectionProperties)

// Cell 6: Verify the load (optional)
%scala
println(s"Successfully loaded ${orderHeaderDF.count()} records to SQL Server table: order_header_sql_server")






















44444444444444


// Cell 1: Set up connection properties
%scala
import java.util.Properties
val connectionProperties = new Properties()
var jdbcPassword = dbutils.secrets.get(scope = "OI_Secrets", key = "oifrontdbo")
connectionProperties.put("user", s"oifrontdbowner")
connectionProperties.put("password", s"${jdbcPassword}")

// Cell 2: Set up JDBC connection string (make sure jdbcHostname and jdbcDatabase are defined)
%scala
// If not already defined, set these variables:
// val jdbcHostname = "your-server-name.database.windows.net"
// val jdbcDatabase = "your-database-name"

val jdbcUrl = s"jdbc:sqlserver://${jdbcHostname}:1433;database=${jdbcDatabase};encrypt=true;trustServerCertificate=false;hostNameInCertificate=*.database.windows.net;loginTimeout=30"

// Cell 3: Set driver class
%scala
val driverClass = "com.microsoft.sqlserver.jdbc.SQLServerDriver"
connectionProperties.setProperty("Driver", driverClass)

// Cell 4: Read the Databricks table
%scala
val orderHeaderDF = spark.table("order_header")

// Cell 5: Write data to SQL Server (creates table if it doesn't exist)
%scala
orderHeaderDF.write
  .mode("overwrite")  // Options: "overwrite", "append", "ignore", "error"
  .option("createTableOptions", "")  // Add any SQL Server specific table options here if needed
  .jdbc(jdbcUrl, "order_header_sql_server", connectionProperties)

// Cell 6: Verify the load (optional)
%scala
println(s"Successfully loaded ${orderHeaderDF.count()} records to SQL Server table: order_header_sql_server")

// Cell 7: Alternative - Explicit table creation check (optional approach)
%scala
import java.sql.DriverManager

// Check if table exists and create if needed
val connection = DriverManager.getConnection(jdbcUrl, connectionProperties)
try {
  val stmt = connection.createStatement()
  
  // Check if table exists
  val checkTableQuery = """
    IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'order_header_sql_server')
    BEGIN
      -- Table will be created by Spark, but you can customize the CREATE TABLE statement here if needed
      PRINT 'Table will be created by Spark'
    END
  """
  
  stmt.execute(checkTableQuery)
  stmt.close()
} finally {
  connection.close()
}

// Now write the data
orderHeaderDF.write
  .mode("append")  // Use append mode after ensuring table exists
  .jdbc(jdbcUrl, "order_header_sql_server", connectionProperties)
