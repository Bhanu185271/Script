#  MWE (Medical Words Examples) â€” Individual Endpoint

MWE_TABLE = "hive_metastore.fieldforce_navigator_deployment.llm_medical_words_examples"
MARKET_BRAND_TABLE = "hive_metastore.fieldforce_navigator_deployment.audio_market_brand_config"

# Cache for valid brands 
_valid_brands_cache = None
_cache_timestamp = None

import time
from datetime import datetime, timedelta

def _clean(s):  
    return " ".join(str(s).strip().split()) if s is not None else ""

def _sq(s):     
    return str(s).replace("'", "''")

def _get_valid_brands(force_refresh=False):
    """
    Get valid brands from audio_market_brand_config table.
    Cache the results to avoid repeated queries.
    Returns a set of valid brands.
    """
    global _valid_brands_cache, _cache_timestamp
    
    # Refresh cache every 5 minutes or on force_refresh
    cache_duration = timedelta(minutes=5)
    current_time = datetime.now()
    
    if (not force_refresh and 
        _valid_brands_cache is not None and 
        _cache_timestamp is not None and 
        current_time - _cache_timestamp < cache_duration):
        return _valid_brands_cache
    
    try:
        # Query distinct brands
        sql = f"""
            SELECT 
                DISTINCT UPPER(TRIM(BRAND)) as BRAND
            FROM {MARKET_BRAND_TABLE}
            WHERE BRAND IS NOT NULL
        """
        
        df = dc.execute_query(sql)
        
        if df is not None and not df.empty:
            # Create set for fast lookup
            valid_brands = set(df['BRAND'].dropna().unique())
            
            _valid_brands_cache = valid_brands
            _cache_timestamp = current_time
        else:
            # Empty table or query failed
            _valid_brands_cache = set()
            _cache_timestamp = current_time
            
    except Exception as e:
        print(f"Error fetching valid brands: {str(e)}")
        # Return empty set on error
        return set()
    
    return _valid_brands_cache

def _validate_brand(brand):
    """
    Check if brand exists in the audio_market_brand_config table
    """
    valid_brands = _get_valid_brands()
    
    brand_upper = brand.upper().strip()
    
    return brand_upper in valid_brands

def _exists_mwe_row(brand, incorrect, corrected):
    # case-insensitive duplicate check 
    sql = f"""
        SELECT *
        FROM {MWE_TABLE}
        WHERE UPPER(TRIM(BRAND))          = UPPER(TRIM('{_sq(brand)}'))
          AND UPPER(TRIM(INCORRECT_TERM)) = UPPER(TRIM('{_sq(incorrect)}'))
          AND UPPER(TRIM(CORRECTED_TERM)) = UPPER(TRIM('{_sq(corrected)}'))
        LIMIT 1
    """
    df = dc.execute_query(sql)
    return df is not None and not df.empty

def _insert_mwe_row(brand, incorrect, corrected, added_by):
    sql = f"""
        INSERT INTO {MWE_TABLE}
            (BRAND, INCORRECT_TERM, CORRECTED_TERM, ADDED_BY, ENTRY_TIME)
        VALUES
            ('{_sq(brand)}','{_sq(incorrect)}','{_sq(corrected)}','{_sq(added_by)}',CURRENT_TIMESTAMP())
    """
    dc.execute_non_query(sql)

# GET: column definitions + simple post template 
@app.route("/llm_mwe_table", methods=["GET"])
def mwe_get():
    try:
        # Include valid brands in the response
        valid_brands = _get_valid_brands()
        
        definitions = {
            "sample_json": {
                "BRAND": {
                    "Example Values": ["SHINGRIX", "AREXVY"],
                    "Description": "Brand name",
                    "Parameter_type": "Mandatory",
                    "Valid_Values_Count": len(valid_brands)
                },
                "INCORRECT_TERM": {
                    "Example Values": ["Chingrix", "Arexyv"],
                    "Description": "Misspelt or wrong medical term",
                    "Parameter_type": "Mandatory"
                },
                "CORRECTED_TERM": {
                    "Example Values": ["Shingrix", "AREXVY"],
                    "Description": "Correct replacement term",
                    "Parameter_type": "Mandatory"
                },
                "ADDED_BY": {
                    "Example Values": ["abc.x.abc@gsk.com"],
                    "Description": "Auto-picked from 'Username' header in POST",
                    "Parameter_type": "Mandatory"
                },
                "ENTRY_TIME": {
                    "Example Values": ["current_timestamp()"],
                    "Description": "Set by system at insert time",
                    "Parameter_type": "Auto-generated"
                }
            },
            "post_request_template_json": {
                "BRAND": "SHINGRIX",
                "INCORRECT_TERM": "Chingrix",
                "CORRECTED_TERM": "Shingrix"
            },
            "excel_upload_instructions": {
                "expected_extension": ".xlsx",
                "form_field_name": "file",
                "required_columns": ["BRAND", "INCORRECT_TERM", "CORRECTED_TERM"],
                "notes": [
                    "Tablename : hive_metastore.fieldforce_navigator_deployment.llm_medical_words_examples",
                    "BRAND must exist in audio_market_brand_config table",
                    "Incorrect term and Corrected term cannot be the same (case-insensitive)",
                    "Duplicate records will be skipped automatically"
                ]
            },
            # Include valid values for reference
            "valid_brands": sorted(list(valid_brands)) if valid_brands else []
        }
        return jsonify(definitions), status.HTTP_200_OK
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), status.HTTP_500_INTERNAL_SERVER_ERROR

# POST: JSON single list OR Excel
@app.route("/llm_mwe_table", methods=["POST"])
def mwe_post():
    try:
        # username 
        added_by = _clean(request.headers.get("Username", "") or "")
        if not added_by:
            return jsonify({"error": "Missing 'Username' in headers."}), status.HTTP_400_BAD_REQUEST

        # Refresh cache at the start of POST request to get latest valid values
        _get_valid_brands(force_refresh=True)

        rows = []  # list of (brand, incorrect, corrected)

        if "file" in request.files:
            # Excel (multipart/form-data)
            f = request.files["file"]
            fname = (f.filename or "").lower().strip()
            if not fname.endswith(".xlsx"):
                return jsonify({"error": "Only .xlsx files are supported for bulk upload."}), status.HTTP_400_BAD_REQUEST

            df = pd.read_excel(f, engine="openpyxl")
            df.columns = [str(c).strip().upper() for c in df.columns]

            req = ["BRAND", "INCORRECT_TERM", "CORRECTED_TERM"]
            missing = [c for c in req if c not in df.columns]
            if missing:
                return jsonify({"error": f"Missing required columns in Excel: {', '.join(missing)}"}), status.HTTP_400_BAD_REQUEST

            df = df.replace({pd.NA: "", None: ""}).fillna("")
            for idx, r in df.iterrows():
                brand     = _clean(r.get("BRAND", ""))
                incorrect = _clean(r.get("INCORRECT_TERM", ""))
                corrected = _clean(r.get("CORRECTED_TERM", ""))
                if not brand or not incorrect or not corrected:
                    return jsonify({"status": "error",
                                    "message": f"Row {int(idx)+2}: Missing BRAND/INCORRECT_TERM/CORRECTED_TERM."}), status.HTTP_400_BAD_REQUEST

                # Validate BRAND
                if not _validate_brand(brand):
                    return jsonify({
                        "status": "error",
                        "message": f"Row {int(idx)+2}: Invalid BRAND '{brand}'. This brand does not exist in audio_market_brand_config table."
                    }), status.HTTP_400_BAD_REQUEST

                # incorrect term and corrected term should not be same
                if incorrect.strip().lower() == corrected.strip().lower():
                    return jsonify({"status": "error",
                                    "message": f"Row {int(idx)+2}: INCORRECT_TERM and CORRECTED_TERM cannot be the same."}), status.HTTP_400_BAD_REQUEST

                rows.append((brand, incorrect, corrected))
        else:
            # JSON (single object or list)
            body = request.get_json(force=True, silent=True) or {}
            items = body if isinstance(body, list) else [body]
            for i, rec in enumerate(items, start=1):
                brand     = _clean(rec.get("BRAND", ""))
                incorrect = _clean(rec.get("INCORRECT_TERM", ""))
                corrected = _clean(rec.get("CORRECTED_TERM", ""))
                if not brand or not incorrect or not corrected:
                    return jsonify({"status": "error",
                                    "message": f"Item {i}: Missing BRAND/INCORRECT_TERM/CORRECTED_TERM."}), status.HTTP_400_BAD_REQUEST

                # Validate BRAND
                if not _validate_brand(brand):
                    return jsonify({
                        "status": "error",
                        "message": f"Item {i}: Invalid BRAND '{brand}'. This brand does not exist in audio_market_brand_config table."
                    }), status.HTTP_400_BAD_REQUEST

                if incorrect.strip().lower() == corrected.strip().lower():
                    return jsonify({"status": "error",
                                    "message": f"Item {i}: INCORRECT_TERM and CORRECTED_TERM cannot be the same."}), status.HTTP_400_BAD_REQUEST
                rows.append((brand, incorrect, corrected))

        if not rows:
            return jsonify({"error": "No valid rows to process."}), status.HTTP_400_BAD_REQUEST

        # process:  INSERT : skip duplicates
        inserted = 0
        duplicates = []
        errors = []
        invalid_brands = []

        for idx, (brand, incorrect, corrected) in enumerate(rows, start=1):
            try:
                # Additional validation for batch processing
                if not _validate_brand(brand):
                    invalid_brands.append({
                        "row": idx,
                        "BRAND": brand,
                        "reason": f"BRAND not found in audio_market_brand_config"
                    })
                    continue

                if _exists_mwe_row(brand, incorrect, corrected):
                    duplicates.append({
                        "row": idx,
                        "BRAND": brand,
                        "INCORRECT_TERM": incorrect,
                        "CORRECTED_TERM": corrected,
                        "reason": "duplicate"
                    })
                    continue

                _insert_mwe_row(brand, incorrect, corrected, added_by)
                inserted += 1

            except Exception as row_err:
                errors.append({
                    "row": idx,
                    "BRAND": brand,
                    "INCORRECT_TERM": incorrect,
                    "CORRECTED_TERM": corrected,
                    "error": str(row_err)
                })

        response = {
            "status": "success" if inserted and not errors else ("partial" if inserted else "no-change"),
            "mode": "excel" if "file" in request.files else "json",
            "inserted_count": inserted,
            "duplicate_count": len(duplicates),  
            "skipped_duplicates": duplicates,
            "invalid_brands": invalid_brands,
            "row_errors": errors
        }
        
        # Remove empty lists from response for cleaner output
        response = {k: v for k, v in response.items() if not (isinstance(v, list) and len(v) == 0)}

        return jsonify(response), (status.HTTP_201_CREATED if inserted else status.HTTP_200_OK)

    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), status.HTTP_500_INTERNAL_SERVER_ERROR










------------------------------------------------------------------------------
#  MWE (Medical Words Examples) â€“ Individual Endpoint

MWE_TABLE = "hive_metastore.fieldforce_navigator_deployment.llm_medical_words_examples"

def _clean(s):  
    return " ".join(str(s).strip().split()) if s is not None else ""

def _sq(s):     
    return str(s).replace("'", "''")

def _exists_mwe_row(brand, incorrect, corrected):
    # case-insensitive duplicate check 
    sql = f"""
        SELECT *
        FROM {MWE_TABLE}
        WHERE UPPER(TRIM(BRAND))          = UPPER(TRIM('{_sq(brand)}'))
          AND UPPER(TRIM(INCORRECT_TERM)) = UPPER(TRIM('{_sq(incorrect)}'))
          AND UPPER(TRIM(CORRECTED_TERM)) = UPPER(TRIM('{_sq(corrected)}'))
        LIMIT 1
    """
    df = dc.execute_query(sql)
    return df is not None and not df.empty

def _insert_mwe_row(brand, incorrect, corrected, added_by):
    sql = f"""
        INSERT INTO {MWE_TABLE}
            (BRAND, INCORRECT_TERM, CORRECTED_TERM, ADDED_BY, ENTRY_TIME)
        VALUES
            ('{_sq(brand)}','{_sq(incorrect)}','{_sq(corrected)}','{_sq(added_by)}',CURRENT_TIMESTAMP())
    """
    dc.execute_non_query(sql)

# GET: column definitions + simple post template 
@app.route("/llm_mwe_table", methods=["GET"])
def mwe_get():
    try:
        definitions = {
            "sample_json": {
                "BRAND": {
                    "Example Values": ["SHINGRIX", "AREXVY"],
                    "Description": "Brand name",
                    "Parameter_type": "Mandatory"
                },
                "INCORRECT_TERM": {
                    "Example Values": ["Chingrix", "Arexyv"],
                    "Description": "Misspelt or wrong medical term",
                    "Parameter_type": "Mandatory"
                },
                "CORRECTED_TERM": {
                    "Example Values": ["Shingrix", "AREXVY"],
                    "Description": "Correct replacement term",
                    "Parameter_type": "Mandatory"
                },
                "ADDED_BY": {
                    "Example Values": ["abc.x.abc@gsk.com"],
                    "Description": "Auto-picked from 'Username' header in POST",
                    "Parameter_type": "Mandatory"
                },
                "ENTRY_TIME": {
                    "Example Values": ["current_timestamp()"],
                    "Description": "Set by system at insert time",
                    "Parameter_type": "Auto-generated"
                }
            },
            "post_request_template_json": {
                "BRAND": "SHINGRIX",
                "INCORRECT_TERM": "Chingrix",
                "CORRECTED_TERM": "Shingrix"
            },
            "excel_upload_instructions": {
                "expected_extension": ".xlsx",
                "form_field_name": "file",
                "required_columns": ["BRAND", "INCORRECT_TERM", "CORRECTED_TERM"],
                "notes": [
                    "Tablename : hive_metastore.fieldforce_navigator_deployment.llm_medical_words_examples",
                    "Incorrect term and Corrected term cannot be the same (case-insensitive)",
                    "Duplicate records will be skipped automatically"
                ]
            }
        }
        return jsonify(definitions), status.HTTP_200_OK
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), status.HTTP_500_INTERNAL_SERVER_ERROR

# POST: JSON single list OR Excel
@app.route("/llm_mwe_table", methods=["POST"])
def mwe_post():
    try:
        # username 
        added_by = _clean(request.headers.get("Username", "") or "")
        if not added_by:
            return jsonify({"error": "Missing 'Username' in headers."}), status.HTTP_400_BAD_REQUEST

        rows = []  # list of (brand, incorrect, corrected)

        if "file" in request.files:
            # Excel (multipart/form-data)
            f = request.files["file"]
            fname = (f.filename or "").lower().strip()
            if not fname.endswith(".xlsx"):
                return jsonify({"error": "Only .xlsx files are supported for bulk upload."}), status.HTTP_400_BAD_REQUEST

            df = pd.read_excel(f, engine="openpyxl")
            df.columns = [str(c).strip().upper() for c in df.columns]

            req = ["BRAND", "INCORRECT_TERM", "CORRECTED_TERM"]
            missing = [c for c in req if c not in df.columns]
            if missing:
                return jsonify({"error": f"Missing required columns in Excel: {', '.join(missing)}"}), status.HTTP_400_BAD_REQUEST

            df = df.replace({pd.NA: "", None: ""}).fillna("")
            for idx, r in df.iterrows():
                brand     = _clean(r.get("BRAND", ""))
                incorrect = _clean(r.get("INCORRECT_TERM", ""))
                corrected = _clean(r.get("CORRECTED_TERM", ""))
                if not brand or not incorrect or not corrected:
                    return jsonify({"status": "error",
                                    "message": f"Row {int(idx)+2}: Missing BRAND/INCORRECT_TERM/CORRECTED_TERM."}), status.HTTP_400_BAD_REQUEST

                # incorrect term and corrected term should not be same
                if incorrect.strip().lower() == corrected.strip().lower():
                    return jsonify({"status": "error",
                                    "message": f"Row {int(idx)+2}: INCORRECT_TERM and CORRECTED_TERM cannot be the same."}), status.HTTP_400_BAD_REQUEST

                rows.append((brand, incorrect, corrected))
        else:
            # JSON (single object or list)
            body = request.get_json(force=True, silent=True) or {}
            items = body if isinstance(body, list) else [body]
            for i, rec in enumerate(items, start=1):
                brand     = _clean(rec.get("BRAND", ""))
                incorrect = _clean(rec.get("INCORRECT_TERM", ""))
                corrected = _clean(rec.get("CORRECTED_TERM", ""))
                if not brand or not incorrect or not corrected:
                    return jsonify({"status": "error",
                                    "message": f"Item {i}: Missing BRAND/INCORRECT_TERM/CORRECTED_TERM."}), status.HTTP_400_BAD_REQUEST
                if incorrect.strip().lower() == corrected.strip().lower():
                    return jsonify({"status": "error",
                                    "message": f"Item {i}: INCORRECT_TERM and CORRECTED_TERM cannot be the same."}), status.HTTP_400_BAD_REQUEST
                rows.append((brand, incorrect, corrected))

        if not rows:
            return jsonify({"error": "No valid rows to process."}), status.HTTP_400_BAD_REQUEST

        # process:  INSERT : skip duplicates
        inserted = 0
        duplicates = []
        errors = []

        for idx, (brand, incorrect, corrected) in enumerate(rows, start=1):
            try:
                if _exists_mwe_row(brand, incorrect, corrected):
                    duplicates.append({
                        "row": idx,
                        "BRAND": brand,
                        "INCORRECT_TERM": incorrect,
                        "CORRECTED_TERM": corrected,
                        "reason": "duplicate"
                    })
                    continue

                _insert_mwe_row(brand, incorrect, corrected, added_by)
                inserted += 1

            except Exception as row_err:
                errors.append({
                    "row": idx,
                    "BRAND": brand,
                    "INCORRECT_TERM": incorrect,
                    "CORRECTED_TERM": corrected,
                    "error": str(row_err)
                })

        return jsonify({
            "status": "success" if inserted and not errors else ("partial" if inserted else "no-change"),
            "mode": "excel" if "file" in request.files else "json",
            "inserted_count": inserted,
            "duplicate_count": len(duplicates),  
            "skipped_duplicates": duplicates,
            "row_errors": errors
        }), (status.HTTP_201_CREATED if inserted else status.HTTP_200_OK)

    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), status.HTTP_500_INTERNAL_SERVER_ERROR























--------------------------------------------------------------






"""
Module to define all available routes
"""
from flask import jsonify, Response
from Api import DatabricksToken as dt
from Api import DataConsumption as dc
from Api import app
from databricks import sql		
from flask import Flask, request, jsonify
from flask_api import status

import hashlib, json, logging, traceback
import pandas as pd
import os
import re
import json
# from flask_restplus import Resource
from cachetools import TTLCache
import datetime
import copy
from diskcache import Cache
import shutil



#  MWE (Medical Words Examples) â€“ Individual Endpoint

MWE_TABLE = "hive_metastore.fieldforce_navigator_deployment.llm_medical_words_examples"

def _clean(s):  
    return " ".join(str(s).strip().split()) if s is not None else ""

def _sq(s):     
    return str(s).replace("'", "''")

def _exists_mwe_row(brand, incorrect, corrected):
    # case-insensitive duplicate check 
    sql = f"""
        SELECT *
        FROM {MWE_TABLE}
        WHERE UPPER(TRIM(BRAND))          = UPPER(TRIM('{_sq(brand)}'))
          AND UPPER(TRIM(INCORRECT_TERM)) = UPPER(TRIM('{_sq(incorrect)}'))
          AND UPPER(TRIM(CORRECTED_TERM)) = UPPER(TRIM('{_sq(corrected)}'))
        LIMIT 1
    """
    df = dc.execute_query(sql)
    return df is not None and not df.empty

def _insert_mwe_row(brand, incorrect, corrected, added_by):
    sql = f"""
        INSERT INTO {MWE_TABLE}
            (BRAND, INCORRECT_TERM, CORRECTED_TERM, ADDED_BY, ENTRY_TIME)
        VALUES
            ('{_sq(brand)}','{_sq(incorrect)}','{_sq(corrected)}','{_sq(added_by)}',CURRENT_TIMESTAMP())
    """
    dc.execute_non_query(sql)

# GET: column definitions + simple post template 
@app.route("/llm_mwe_table", methods=["GET"])
def mwe_get():
    try:
        definitions = {
            "sample_json": {
                "BRAND": {
                    "Example Values": ["SHINGRIX", "AREXVY"],
                    "Description": "Brand name",
                    "Parameter_type": "Mandatory"
                },
                "INCORRECT_TERM": {
                    "Example Values": ["Chingrix", "Arexyv"],
                    "Description": "Misspelt or wrong medical term",
                    "Parameter_type": "Mandatory"
                },
                "CORRECTED_TERM": {
                    "Example Values": ["Shingrix", "AREXVY"],
                    "Description": "Correct replacement term",
                    "Parameter_type": "Mandatory"
                },
                "ADDED_BY": {
                    "Example Values": ["abc.x.abc@gsk.com"],
                    "Description": "Auto-picked from 'Username' header in POST",
                    "Parameter_type": "Mandatory"
                },
                "ENTRY_TIME": {
                    "Example Values": ["current_timestamp()"],
                    "Description": "Set by system at insert time",
                    "Parameter_type": "Auto-generated"
                }
            },
            "post_request_template_json": {
                "BRAND": "SHINGRIX",
                "INCORRECT_TERM": "Chingrix",
                "CORRECTED_TERM": "Shingrix"
            },
            "excel_upload_instructions": {
                "expected_extension": ".xlsx",
                "form_field_name": "file",
                "required_columns": ["BRAND", "INCORRECT_TERM", "CORRECTED_TERM"],
                "notes": [
                    "Tablename : hive_metastore.fieldforce_navigator_deployment.llm_medical_words_examples",
                    "Incorrect term and Corrected term cannot be the same (case-insensitive).",
                    "Duplicate records are skipped automatically."
                ]
            }
        }
        return jsonify(definitions), status.HTTP_200_OK
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), status.HTTP_500_INTERNAL_SERVER_ERROR

# POST: JSON single list OR Excel
@app.route("/llm_mwe_table", methods=["POST"])
def mwe_post():
    try:
        # username 
        added_by = _clean(request.headers.get("Username", "") or "")
        if not added_by:
            return jsonify({"error": "Missing 'Username' in headers."}), status.HTTP_400_BAD_REQUEST

        rows = []  # list of (brand, incorrect, corrected)

        if "file" in request.files:
            # Excel (multipart/form-data)
            f = request.files["file"]
            fname = (f.filename or "").lower().strip()
            if not fname.endswith(".xlsx"):
                return jsonify({"error": "Only .xlsx files are supported for bulk upload."}), status.HTTP_400_BAD_REQUEST

            df = pd.read_excel(f, engine="openpyxl")
            df.columns = [str(c).strip().upper() for c in df.columns]

            req = ["BRAND", "INCORRECT_TERM", "CORRECTED_TERM"]
            missing = [c for c in req if c not in df.columns]
            if missing:
                return jsonify({"error": f"Missing required columns in Excel: {', '.join(missing)}"}), status.HTTP_400_BAD_REQUEST

            df = df.replace({pd.NA: "", None: ""}).fillna("")
            for idx, r in df.iterrows():
                brand     = _clean(r.get("BRAND", ""))
                incorrect = _clean(r.get("INCORRECT_TERM", ""))
                corrected = _clean(r.get("CORRECTED_TERM", ""))
                if not brand or not incorrect or not corrected:
                    return jsonify({"status": "error",
                                    "message": f"Row {int(idx)+2}: Missing BRAND/INCORRECT_TERM/CORRECTED_TERM."}), status.HTTP_400_BAD_REQUEST

                # incorrect term and corrected term should not be same
                if incorrect.strip().lower() == corrected.strip().lower():
                    return jsonify({"status": "error",
                                    "message": f"Row {int(idx)+2}: INCORRECT_TERM and CORRECTED_TERM cannot be the same."}), status.HTTP_400_BAD_REQUEST

                rows.append((brand, incorrect, corrected))
        else:
            # JSON (single object or list)
            body = request.get_json(force=True, silent=True) or {}
            items = body if isinstance(body, list) else [body]
            for i, rec in enumerate(items, start=1):
                brand     = _clean(rec.get("BRAND", ""))
                incorrect = _clean(rec.get("INCORRECT_TERM", ""))
                corrected = _clean(rec.get("CORRECTED_TERM", ""))
                if not brand or not incorrect or not corrected:
                    return jsonify({"status": "error",
                                    "message": f"Item {i}: Missing BRAND/INCORRECT_TERM/CORRECTED_TERM."}), status.HTTP_400_BAD_REQUEST
                if incorrect.strip().lower() == corrected.strip().lower():
                    return jsonify({"status": "error",
                                    "message": f"Item {i}: INCORRECT_TERM and CORRECTED_TERM cannot be the same."}), status.HTTP_400_BAD_REQUEST
                rows.append((brand, incorrect, corrected))

        if not rows:
            return jsonify({"error": "No valid rows to process."}), status.HTTP_400_BAD_REQUEST

        # process:  INSERT : skip duplicates
        inserted = 0
        duplicates = []
        errors = []

        for idx, (brand, incorrect, corrected) in enumerate(rows, start=1):
            try:
                if _exists_mwe_row(brand, incorrect, corrected):
                    duplicates.append({
                        "row": idx,
                        "BRAND": brand,
                        "INCORRECT_TERM": incorrect,
                        "CORRECTED_TERM": corrected,
                        "reason": "duplicate"
                    })
                    continue

                _insert_mwe_row(brand, incorrect, corrected, added_by)
                inserted += 1

            except Exception as row_err:
                errors.append({
                    "row": idx,
                    "BRAND": brand,
                    "INCORRECT_TERM": incorrect,
                    "CORRECTED_TERM": corrected,
                    "error": str(row_err)
                })

        return jsonify({
            "status": "success" if inserted and not errors else ("partial" if inserted else "no-change"),
            "mode": "excel" if "file" in request.files else "json",
            "inserted_count": inserted,
            "duplicate_count": len(duplicates),  
            "skipped_duplicates": duplicates,
            "row_errors": errors
        }), (status.HTTP_201_CREATED if inserted else status.HTTP_200_OK)

    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), status.HTTP_500_INTERNAL_SERVER_ERROR

















---------------------------------------------------------------------------------------------------------------------------------------------------------------------

#  MWE (Medical Words Examples) â€“ Individual Endpoint 

MWE_TABLE = "hive_metastore.fieldforce_navigator_deployment.llm_medical_words_examples"


def _clean(s):  
    return " ".join(str(s).strip().split()) if s is not None else ""

def _sq(s):     
    return str(s).replace("'", "''")

def _exists_mwe_row(brand, incorrect, corrected):
    # case-insensitive duplicate check 
    sql = f"""
        SELECT *
        FROM {MWE_TABLE}
        WHERE UPPER(TRIM(BRAND))          = UPPER(TRIM('{_sq(brand)}'))
          AND UPPER(TRIM(INCORRECT_TERM)) = UPPER(TRIM('{_sq(incorrect)}'))
          AND UPPER(TRIM(CORRECTED_TERM)) = UPPER(TRIM('{_sq(corrected)}'))
        LIMIT 1
    """
    df = dc.execute_query(sql)
    return df is not None and not df.empty

def _insert_mwe_row(brand, incorrect, corrected, added_by):
    sql = f"""
        INSERT INTO {MWE_TABLE}
            (BRAND, INCORRECT_TERM, CORRECTED_TERM, ADDED_BY, ENTRY_TIME)
        VALUES
            ('{_sq(brand)}','{_sq(incorrect)}','{_sq(corrected)}','{_sq(added_by)}',CURRENT_TIMESTAMP())
    """
    dc.execute_non_query(sql)

# GET: column definitions + simple post template 
@app.route("/llm_mwe_table", methods=["GET"])
def mwe_get():
    try:
        definitions = {
            "sample_json": {
                
                "BRAND": {
                    "Example Values": ["SHINGRIX", "AREXVY"],
                    "Description": "Brand name",
                    "Parameter_type": "Mandatory"
                },
                "INCORRECT_TERM": {
                    "Example Values": ["Chingrix", "rexyv"],
                    "Description": "Misspelt or wrong medical term",
                    "Parameter_type": "Mandatory"
                },
                "CORRECTED_TERM": {
                    "Example Values": ["Shingrix", "AREXVY"],
                    "Description": "Correct replacement term",
                    "Parameter_type": "Mandatory"
                },
                "ADDED_BY": {
                    "Example Values": ["abc.x.abc@gsk.com"],
                    "Description": "Auto-picked from 'Username' header in POST",
                    "Parameter_type": "Mandatory"
                },
                "ENTRY_TIME": {
                    "Example Values": ["current_timestamp()"],
                    "Description": "Set by system at insert time",
                    "Parameter_type": "Auto-generated"
                }
            },
            "post_request_template_json": {
                "BRAND": "SHINGRIX",
                "INCORRECT_TERM": "Chingrix",
                "CORRECTED_TERM": "Shingrix"
            },
            "excel_upload_instructions": {
                "expected_extension": ".xlsx",
                "form_field_name": "file",
                "required_columns": ["BRAND", "INCORRECT_TERM", "CORRECTED_TERM"],
                "notes": [
                    "Tablename : hive_metastore.fieldforce_navigator_deployment.llm_medical_words_examples" 
                ]
                
            }
        }
        return jsonify(definitions), status.HTTP_200_OK
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), status.HTTP_500_INTERNAL_SERVER_ERROR

# POST: JSON (single list) OR Excel (.xlsx) 
@app.route("/llm_mwe_table", methods=["POST"])
def mwe_post():
    try:
        # username 
        added_by = _clean(request.headers.get("Username", "") or "")
        if not added_by:
            return jsonify({"error": "Missing 'Username' in headers."}), status.HTTP_400_BAD_REQUEST

        rows = []  # list of (brand, incorrect, corrected)

        if "file" in request.files:
            # Excel (multipart/form-data)
            f = request.files["file"]
            fname = (f.filename or "").lower().strip()
            if not fname.endswith(".xlsx"):
                return jsonify({"error": "Only .xlsx files are supported for bulk upload."}), status.HTTP_400_BAD_REQUEST

            df = pd.read_excel(f, engine="openpyxl")
            df.columns = [str(c).strip().upper() for c in df.columns]

            req = ["BRAND", "INCORRECT_TERM", "CORRECTED_TERM"]
            missing = [c for c in req if c not in df.columns]
            if missing:
                return jsonify({"error": f"Missing required columns in Excel: {', '.join(missing)}"}), status.HTTP_400_BAD_REQUEST

            df = df.replace({pd.NA: "", None: ""}).fillna("")
            for idx, r in df.iterrows():
                brand     = _clean(r.get("BRAND", ""))
                incorrect = _clean(r.get("INCORRECT_TERM", ""))
                corrected = _clean(r.get("CORRECTED_TERM", ""))
                if not brand or not incorrect or not corrected:
                    return jsonify({"status": "error",
                                    "message": f"Row {int(idx)+2}: Missing BRAND/INCORRECT_TERM/CORRECTED_TERM."}), status.HTTP_400_BAD_REQUEST
                rows.append((brand, incorrect, corrected))
        else:
            # JSON (single object or list)
            body = request.get_json(force=True, silent=True) or {}
            items = body if isinstance(body, list) else [body]
            for i, rec in enumerate(items, start=1):
                brand     = _clean(rec.get("BRAND", ""))
                incorrect = _clean(rec.get("INCORRECT_TERM", ""))
                corrected = _clean(rec.get("CORRECTED_TERM", ""))
                if not brand or not incorrect or not corrected:
                    return jsonify({"status": "error",
                                    "message": f"Item {i}: Missing BRAND/INCORRECT_TERM/CORRECTED_TERM."}), status.HTTP_400_BAD_REQUEST
                rows.append((brand, incorrect, corrected))

        if not rows:
            return jsonify({"error": "No valid rows to process."}), status.HTTP_400_BAD_REQUEST

        #  INSERT (skip duplicates)
        inserted = 0
        duplicates = []
        errors = []

        for idx, (brand, incorrect, corrected) in enumerate(rows, start=1):
            try:
                if _exists_mwe_row(brand, incorrect, corrected):
                    duplicates.append({
                        "row": idx,
                        "BRAND": brand,
                        "INCORRECT_TERM": incorrect,
                        "CORRECTED_TERM": corrected,
                        "reason": "duplicate"
                    })
                    continue

                _insert_mwe_row(brand, incorrect, corrected, added_by)
                inserted += 1

            except Exception as row_err:
                errors.append({
                    "row": idx,
                    "BRAND": brand,
                    "INCORRECT_TERM": incorrect,
                    "CORRECTED_TERM": corrected,
                    "error": str(row_err)
                })

        return jsonify({
            "status": "success" if inserted and not errors else ("partial" if inserted else "no-change"),
            "mode": "excel" if "file" in request.files else "json",
            "inserted_count": inserted,
            "skipped_duplicates": duplicates,
            "row_errors": errors
        }), (status.HTTP_201_CREATED if inserted else status.HTTP_200_OK)

    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), status.HTTP_500_INTERNAL_SERVER_ERROR
