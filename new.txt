TABLE_FQN = "hive_metastore.fieldforce_navigator_deployment.llm_model_lookup"
 
def _mdl_clean(s):
    # trim + whitespace spaces
    return " ".join(str(s).strip().split())
 
def _mdl_sq(s):
    # escape single quotes
    return str(s).replace("'", "''")
 
def _mdl_require(body):
    required = [
        "MODEL_NAME", "DEPLOYMENT_NAME",
        "BRAND", "MARKET", "REGION",
        "TOKEN_LIMIT", "INPUT_TOKEN_LIMIT", "OUTPUT_TOKEN_LIMIT",
        "TOKEN_RATE_LIMIT", "PROJECT_INPUT_LIMIT"
    ]
    return [k for k in required if k not in body or str(body.get(k, "")).strip() == ""]
 
def _to_int(name, val):
    try:
        return int(str(val).strip())
    except Exception:
        raise ValueError(f"'{name}' must be an integer")
 
def _mdl_exists(model_name, deployment_name, brand, market, region):
    # config as unique 
    sql = f"""
        SELECT *
        FROM {TABLE_FQN}
        WHERE UPPER(TRIM(MODEL_NAME))      = UPPER(TRIM('{_mdl_sq(model_name)}'))
          AND UPPER(TRIM(DEPLOYMENT_NAME)) = UPPER(TRIM('{_mdl_sq(deployment_name)}'))
          AND UPPER(TRIM(BRAND))           = UPPER(TRIM('{_mdl_sq(brand)}'))
          AND UPPER(TRIM(MARKET))          = UPPER(TRIM('{_mdl_sq(market)}'))
          AND UPPER(TRIM(REGION))          = UPPER(TRIM('{_mdl_sq(region)}'))
        
    """
    df = dc.execute_query(sql)
    return df is not None and not df.empty
 
def _mdl_insert(model_name, deployment_name, token_limit,
                brand, market, region,
                input_token_limit, output_token_limit,
                token_rate_limit, project_input_limit, added_by):
    sql = f"""
        INSERT INTO {TABLE_FQN}
            (MODEL_NAME, DEPLOYMENT_NAME, TOKEN_LIMIT,
             BRAND, MARKET, REGION,
             INPUT_TOKEN_LIMIT, OUTPUT_TOKEN_LIMIT, TOKEN_RATE_LIMIT, PROJECT_INPUT_LIMIT,
             ADDED_BY, ENTRY_TIME)
        VALUES
            ('{_mdl_sq(model_name)}', '{_mdl_sq(deployment_name)}', {token_limit},
             '{_mdl_sq(brand)}', '{_mdl_sq(market)}', '{_mdl_sq(region)}',
             {input_token_limit}, {output_token_limit}, {token_rate_limit}, {project_input_limit},
             '{_mdl_sq(added_by)}', CURRENT_TIMESTAMP())
    """
    dc.execute_non_query(sql)
 
@app.route('/llm_model_config', methods=['POST'])
def add_llm_model_limits():
    try:
        body = request.get_json(force=True, silent=True) or {}
 
        # ADDED_BY from request body 
        added_by = _mdl_clean(body.get("ADDED_BY", "")) or _mdl_clean(request.headers.get("Username", "") or "")
        if not added_by:
            return jsonify({"error": "Missing 'ADDED_BY' in body or 'Username' in headers."}), status.HTTP_400_BAD_REQUEST
 
        # check : Required fields present
        missing = _mdl_require(body)
        if missing:
            return jsonify({"error": f"Missing required fields: {', '.join(missing)}"}), status.HTTP_400_BAD_REQUEST
 
        # normalized strings
        model_name      = _mdl_clean(body["MODEL_NAME"])
        deployment_name = _mdl_clean(body["DEPLOYMENT_NAME"])
        brand           = _mdl_clean(body["BRAND"])
        market          = _mdl_clean(body["MARKET"])
        region          = _mdl_clean(body["REGION"])
 
        # Parse integers 
        token_limit         = _to_int("TOKEN_LIMIT", body["TOKEN_LIMIT"])
        input_token_limit   = _to_int("INPUT_TOKEN_LIMIT", body["INPUT_TOKEN_LIMIT"])
        output_token_limit  = _to_int("OUTPUT_TOKEN_LIMIT", body["OUTPUT_TOKEN_LIMIT"])
        token_rate_limit    = _to_int("TOKEN_RATE_LIMIT", body["TOKEN_RATE_LIMIT"])
        project_input_limit = _to_int("PROJECT_INPUT_LIMIT", body["PROJECT_INPUT_LIMIT"])
 
        # non-negative checkpoint
        for k, v in [
            ("TOKEN_LIMIT", token_limit),
            ("INPUT_TOKEN_LIMIT", input_token_limit),
            ("OUTPUT_TOKEN_LIMIT", output_token_limit),
            ("TOKEN_RATE_LIMIT", token_rate_limit),
            ("PROJECT_INPUT_LIMIT", project_input_limit),
        ]:
            if v < 0:
                return jsonify({"error": f"'{k}' must be >= 0"}), status.HTTP_400_BAD_REQUEST
 
        # Duplicate check on the identifying tuple
        if _mdl_exists(model_name, deployment_name, brand, market, region):
            return jsonify({
                "status": "error",
                "message": "Record already exists (case-insensitive).",
                "conflict_on": {
                    "MODEL_NAME": model_name,
                    "DEPLOYMENT_NAME": deployment_name,
                    "BRAND": brand, "MARKET": market, "REGION": region
                }
            }), status.HTTP_409_CONFLICT
 
        # Insert
        _mdl_insert(model_name, deployment_name, token_limit,
                    brand, market, region,
                    input_token_limit, output_token_limit,
                    token_rate_limit, project_input_limit, added_by)
 
        return jsonify({
            "status": "success",
            "message": "Record inserted.",
            "data": {
                "MODEL_NAME": model_name,
                "DEPLOYMENT_NAME": deployment_name,
                "TOKEN_LIMIT": token_limit,
                "BRAND": brand, "MARKET": market, "REGION": region,
                "INPUT_TOKEN_LIMIT": input_token_limit,
                "OUTPUT_TOKEN_LIMIT": output_token_limit,
                "TOKEN_RATE_LIMIT": token_rate_limit,
                "PROJECT_INPUT_LIMIT": project_input_limit,
                "ADDED_BY": added_by
            }
        }), status.HTTP_201_CREATED
 
    except ValueError as ve:
        # Error 400 for bad ints
        return jsonify({"error": str(ve)}), status.HTTP_400_BAD_REQUEST
    except Exception as e:
        logging.error(traceback.format_exc())
        return jsonify({"error": f"Internal server error: {str(e)}"}), status.HTTP_500_INTERNAL_SERVER_ERROR
